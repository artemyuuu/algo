package org.example.ArrayString;
//Дан целочисленный массив nums, отсортированный в порядке неубывания, удалите некоторые дубликаты на месте так,
// чтобы каждый уникальный элемент встречался не более двух раз. Относительный порядок элементов должен остаться прежним.
//Поскольку в некоторых языках невозможно изменить длину массива, результат должен быть помещён в первую часть массива nums.
// Если говорить более формально, то после удаления дубликатов останется k элементов, и первые k элементов nums должны содержать окончательный результат.
// Неважно, что вы оставите за пределами первых k элементов.
//Вернитесь kпосле размещения окончательного результата в первых k ячейках nums.
//Не выделяйте дополнительное место для другого массива. Вы должны сделать это, изменив входной массивна месте с использованием дополнительной памяти O(1).
//Пример 1:
//Входные данные: nums = [1,1,1,2,2,3]
//Выходные данные: 5, nums = [1,1,2,2,3,_]
//Пояснение: Ваша функция должна возвращать k = 5, при этом первые пять элементов nums должны быть равны 1, 1, 2, 2 и 3 соответственно.
//Не имеет значения, что вы оставите после возвращаемого k (поэтому там подчеркивания).
//Пример 2:
//Входные данные: nums = [0,0,1,1,1,1,2,3,3]
//Выходные данные: 7, nums = [0,0,1,1,2,3,3,_,_]
//Пояснение: Ваша функция должна вернуть k = 7, при этом первые семь элементов nums будут равны 0, 0, 1, 1, 2, 3 и 3 соответственно.
//Неважно, что вы оставляете за пределами возвращаемого значения k (поэтому они обозначены подчеркиванием).

public class RemoveDuplicatesFromSortedArrayII4 {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        if (n <= 2) return n;
        int write = 2;
        for (int read = 2; read < n; read++) {
            if (nums[read] != nums[write-2]) {
                nums[write]=nums[read];
                write++;
            }
        }
        return write;
    }
}
